                        README for functracer plugins

                  Copyright (C) 2008-2010 by Nokia Corporation

Contents
--------
 1. Introduction
 2. Plugin Infrastrucuture
 3. Plugin extension
 4. How to use
 5. Plugin details
 6. Issues and Limitations
 7. License


1. Introduction
---------------
Functracer supports plugins. The plugins tell to functracer which set of
functions will be tracked. Only one plugin can be used at each functracer
execution.

Currently, the following plugins are available, including the functions they
track:
- memory: calloc, free, malloc, memalign, posix_memalign, realloc, valloc.
- file: fopen, fclose, open, close, fcloseall, creat, freopen, fdopen,
    accept, dup, dup2, socket, socketpair, fcntl, pipe, inotify_init.
- memtransfer: memcpy, mempcpy, memmove, memccpy, memset, strcpy, strncpy,
    stpcpy, stpncpy, strcat, strncat, bcopy, bzero, strdup, strndup, strdupa, 
    strndupa, wmemcpy, wmempcpy, wmemmove, wmemset, wcscpy, wcsncpy, wcpcpy, 
    wcpncpy, wcscat, wcsncat, wcsdup.
- gobject: g_object_newv, g_object_ref, g_object_unref.
- thread-resource: pthread_create, pthread_join, pthread_detach.  
- shmsysv: shmget, shmctl, shmat, shmdt.
- shmposix: shm_open, shm_unlink, mmap, mmap2, mmap64, munmap
- audit: custom functions, specified with -a option

Plugins are usually installed in /usr/lib/functracer. Memory is the default
plugin, and to switch to the "file" plugin you must use the "-e" option (e.g.
"-e file"). A user-defined plugin can be used by specifying a path to the "-e"
option (e.g. "-e /home/user/plg/foo.so").

2. Plugin infrastructure
------------------------
The basic plugin infrastructure consists of three functions:

- api_version: tells to functracer what API version is supported by the plugin.
  This version is verified by functracer and if it is not compatible, the tool
  refuses to load the plugin.

- library_match: this should return the function names that will be tracked by
  functracer. The function names should match those as exported by the library
  (see more details in "Issues and Limitations" section).

- function_exit: this is the place where the data is collected. In this
  function, the user tells to functracer what to report about the tracked
  function. Usually, function_exit identifies the function name, the resource
  ID and the return value, and events are reported to the trace files using
  the rp_alloc() function for resource allocation and rp_free() for resource
  destruction.

The functracer API must be used for retrieving or logging any data (just add
the correct header in user-defined plugin). See functracer source code for more
details on how to use each function, for example:

- fn_return_value(): get the function return value.
- fn_argument(): get the function argument (numbered starting from zero).
- rp_write_backtraces(): generate backtraces for function call site.
- rp_alloc(): log resource allocation.
- rp_alloc_details: log resoruce allocation with additional description.
- rp_free(): log resource destruction.

- trace_mem_readstr(): get C style string located at the specified address.
- trace_mem_readwstr(): get C style wide string located at the specified address.

3. Plugin extension
-------------------
This section will show step-by-step how to create a new plugin and what is
mandatory.

First, we need to add some header files. See functracer API to know the
functions available and the respective header file. In general, we will use
report functions (report.h), debug messages (debug.h), definitions to processes
(process.h), read function arguments (function.h) and the plugin manager
definitions (plugins.h).

#include "debug.h"
#include "function.h"
#include "plugins.h"
#include "process.h"
#include "report.h"

Secondly, we have to define the plugin version, which must be compatible with
the current functracer plugin API.

#define FOO_API_VERSION "2.0"
static char foo_api_version[] = FOO_API_VERSION;

Third, we define what functions will be tracked, in this example the malloc and
free functions will be tracked. See some considerations about function names in
section "Issues and Limitations".

static int foo_library_match(const char *symname)
{
        return(strcmp(symname, "__libc_malloc") == 0 ||
               strcmp(symname, "__libc_free") == 0);
}

The next step is to define what to do when the function exits. A small example
using some parts of the memory plugin is shown below:

static void foo_function_exit(struct process *proc, const char *name)
{
        /* Get the report data to loggin information. */ 
        struct rp_data *rd = proc->rp_data;

        /* Get the function return value. */
        addr_t retval = fn_return_value(proc);

        /* Get the first function argument. */
        size_t arg0 = fn_argument(proc, 0);

        /* Verify what is the function. */
        if (strcmp(name, "__libc_malloc") == 0) {
                /* Write the data to trace file. */
                rp_alloc(proc, rd->rp_number, "malloc", arg0, retval);

        } else if (strcmp(name, "__libc_free") == 0 ) {
                /* Suppress "free(NULL)" calls from trace output. 
                 * They are a no-op according to ISO 
                 */
                if (arg0 == 0)
                        return;
                /* Write the data to trace file. */
                rp_free(proc, rd->rp_number, "free", arg0);

        } else {
                msg_warn("unexpected function exit (%s)\n", name);
                return;
        }

	/* Increment ID number (this is need to have the ID number correct to
         * next events).
         */
        (rd->rp_number)++;
	/* Write the respective backtraces line to trace file */
        rp_write_backtraces(proc);
}

The last step is to initialize the plugin structure. See example below:

struct plg_api *init()
{
        static struct plg_api ma = {
                .api_version = foo_api_version,
                .function_exit = foo_function_exit,
                .library_match = foo_library_match,
        };
        /* ... */
}

To add the new plugin to functracer sources:
1. Edit the src/modules/Makefile.am and add the foo plugin:
   pkglib_LTLIBRARIES = memory.la file.la
   memory_la_SOURCES = memory.c
   memory_la_LDFLAGS = -no-undefined -module -avoid-version
   file_la_SOURCES = file.c
   file_la_LDFLAGS = -no-undefined -module -avoid-version
   # Add new build lines to foo plugin
   pkglib_LTLIBRARIES += foo.la
   foo_la_SOURCES = foo.c
   foo_la_LDFLAGS = -no-undefined -module -avoid-version

2. Run autoreconf to update Makefiles:
   $ cd functracer-x.y.z
   $ autoreconf -i -f
3. Build and install
   $ ./configure && make
   # make install

The plugin is ready to use! See functracer-x.y.z/src/modules/ for complete
sources of other plugins.

4. How to use
-------------
There are two ways for using plugins:
- Add it to functracer sources (shown in previous section) and install it.
- Give the complete plugin path to functracer.

For the first option you just type the plugin name so the functracer will
look for it in plugins default directory (/usr/lib/functracer):

# functracer -e foo ./my_program

or, if the plugin is installed in another place:

# functracer -e /work/plugins/foo.so ./my_program

Plugins specified by the "-e" option are located using the following logic:
1) Check if a file by that name exists; otherwise
2) Prefix the name with the plugin directory path and append ".so" to it.

5. Plugin details
-----------------

memory
  Memory plugin is used to analyse memory allocations/frees. It reports 
  'memory' resource usage by tracking  calloc, free, malloc, memalign, 
  posix_memalign, realloc, valloc functions.
  
memtransfer
  Memory transfer plugin is used to analyse memory transfer operations.
  It reports 'memtransfer' resource usage by tracking memcpy, mempcpy,
  memmove, memccpy, memset, strcpy, strncpy, stpcpy, stpncpy, strcat,
  strncat, bcopy, bzero, strdup, strndup, strdupa, strndupa, wmemcpy,
  wmempcpy, wmemmove, wmemset, wcscpy, wcsncpy, wcpcpy, wcpncpy, wcscat,
  wcsncat, wcsdup functions.
  
file
  File plugin is used to analyse file usage. It reports the following
  resource usage:
  'fd' - file descriptor usage, tracked by open, open64, close, creat,
         fdopen, accept, dup, dup2, socket, socketpair, fcntl, pipe,
         pipe2, inotify_init functions.
  'fp' - file pointer usage, tracked by fopen, fclose, fcloseall, 
         freopen functions.

gobject
  Gobject plugin is used to analyse gobject creation, references
  and dereferences. It reports 'gobject' resource usage by tracking
  g_object_newv, g_object_ref, g_object_unref functions.

thread-resource
  Thread resource plugin is used to analyse thread creation/destruction.
  It reports 'pthread_t' resource usage by tracking pthread_create, 
  pthread_join, pthread_detach functions.

shmsysv
  Shared memory plugin is used to analyse shared memory creation/
  desctruction and memory attachments/detachments: shmget, shmctl, shmat, 
  shmdt. It resports the following resource usage:
  'segment' - shared memory segment creation/destruction, tracked by
              shmget, shmctl, shmdt functions.
  'address' - shared memory attachements/detachments, tracked by shmat,
              shmdt functions.

shmposix
  Posix shared memory object plugin is used to analyse posix shared memory
  object creation/destruction and memory mapping/unmapping. It reports the
  following resource usage:
  'pshmobj' - posix shared memory object creation/destruction, tracked by
              shm_open, shm_unlink functions.
  'pshmfd'  - posix shared memory object opening/closing, tracked by 
              shm_open, close() functions.
  'pshmmap' - posix shared memory object mapping/unmapping, tracked by 
              mmap, mmap2, mmap64, munmap functions.
  'fshmmap' - file mapping/unmapping, tracked by mmap, mmap2, mmap64, munmap
              functions.
  'shmmap' -  generic shared memory object mapping/unmapping, tracked by 
              mmap, mmap2, mmap64, munmap functions.

   This plugin keeps track on opened file descriptors to determine the
   descriptor 'type' for mapping functions. If the descriptor was opened
   with shm_open, then 'pshmmap' resource type is reported by mapping
   functions. If the descriptor was opened by open, open64, creat functions,
   then 'fshmmap' resource type is reported by mapping functions. Otherwise
   (when the descriptor source was not determined) 'shmmap' resource type
   is reported by mapping functions.

audit
  Audit plugin is used to analyse calls of custom defined functions. Those
  functions are specified with -a command line option:
    -a <symbol>[;<symbol>[;<symbool>...]]
  where <symbol> contains either a custom symbol to track or @<filename>
  specifying file containing a list of custom symbols to track. It uses 
  'virtual'  resource type to report such functions.
  
  

6. Issues and Limitations
-------------------------
Not all functions can be currently tracked by plugins. This happens for two
reasons:

-  Functions should be tracked by using their "public" name as found in the
   library export table. This means that any existing name mangling added by
   the compiler/linker should be used too, otherwise the function is not found
   by BFD. Examples: __close, _IO_fopen, _IO_fclose etc. See the current
   plugins sources for details.

- The instruction rewriting support on ARM is currently limited to a set of
  instructions used by current plugins. This means that some new functions may
  not be allowed to be tracked until the instruction located
  on the function entry is added to the rewrite rules. For such cases, a "SSOL
  unsafe" warning will be print, and the breakpoint will be disabled.
  This is important so that plugins tracking arbitrary functions do not crash
  the target application. For more details, see the source for the
  ssol_prepare_bkpt() function in src/breakpoint-arm.c.

7. License
----------
This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.
